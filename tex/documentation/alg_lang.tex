\section{Data Type}\index{data type}\label{d:sec:data_type}

\subsection{Why Need Data Type}
Languages Python and Matlab/Octave are weakly typed
which can be convenient for writing the code.
However, that is problematic for implementation.
The efficiency is not satisfactory compared to C++,
and sometimes you may encounter ambiguous error information in Matlab.
Therefore, for the sake of efficiency and generality,
ALG language is designed to be \textbf{strongly typed}.

\subsection{Structure}
The type specification is very simple,
because ALG language concentrates on matrices.
Basically, the structure of ALG language is
\[
  \text{\hyperref[d:subsubsec:prefix]{prefix}}+
  \text{\hyperref[d:subsubsec:dim]{dimension}}+
  \text{\hyperref[d:subsubsec:suffix]{suffix}}.
\]
For example, \texttt{f2c} means a matrix (dimension is 2) with data type as float
and property as a constant.

\subsection{Specifiers}\index{specifier}

\subsubsection{Prefix}\index{prefix}\label{d:subsubsec:prefix}

\paragraph{Basic Type Prefix}\index{prefix!basic~type}

Basic type just names the element type.
They are shown in Table~\ref{d:tab:basic_type_prefix}.
\begin{table}[htbp]
  \caption{ALG variable basic type prefix.}
  \label{d:tab:basic_type_prefix}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabularx}{\linewidth}{ccYYY}
    \toprule
    \tbhead{Prefix} & \tbhead{Type} & \tbhead{C++ Type} & \tbhead{Python Type} & \tbhead{\textsc{Matlab}/Octave Type} \\
    \midrule
    \texttt{c}\indexprefix{c} & Complex &
    \href{https://arma.sourceforge.net/docs.html\#cx_double}{\texttt{cx\_double}}
    & \texttt{complex} &
    \href{https://www.mathworks.com/help/matlab/ref/complex.html}{\texttt{complex}} \\
    \texttt{f}\indexprefix{f} & Float & \texttt{double} & \texttt{double} &
    \href{https://www.mathworks.com/help/matlab/ref/double.html}{\texttt{double}} \\
    \texttt{i}\indexprefix{i} & Integer & \texttt{int} & \texttt{int} &
    \href{https://www.mathworks.com/help/matlab/ref/int64.html}{\texttt{int64}} \\
    \texttt{u}\indexprefix{u} & Unsigned Integer &
    \href{https://arma.sourceforge.net/docs.html\#uword}{\texttt{uword}} &
    \texttt{uint} &
    \href{https://www.mathworks.com/help/matlab/ref/uint64.html}{\texttt{uint64}} \\
    \texttt{b}\indexprefix{b} & Boolean & \texttt{bool} & \texttt{bool} &
    \href{https://www.mathworks.com/help/matlab/ref/logical.html}{\texttt{logical}} \\
    \texttt{s}\indexprefix{s} & String &
    \href{https://en.cppreference.com/w/cpp/string/basic_string}{\texttt{std::string}}
    & \texttt{str} &
    \href{https://www.mathworks.com/help/matlab/ref/string.html}{\texttt{string}} \\
    \texttt{h}\indexprefix{h} & Character & \texttt{char} & \texttt{char} &
    \href{https://www.mathworks.com/help/matlab/ref/char.html}{\texttt{char}} \\
    \bottomrule
  \end{tabularx}
\end{table}

\paragraph{Alias Prefix}\index{prefix!alias}
Alias prefixes not only set the element type,
but also the dimension.
They are the one character alias for a two-character type.
A list of alias prefixes is shown in Table~\ref{d:tab:alias_prefix}.
\begin{table}[htbp]
  \caption{ALG variable alias prefix.}
  \label{d:tab:alias_prefix}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabularx}{\linewidth}{YYY}
    \toprule
    \tbhead{Alias Prefix} & \tbhead{Type} & \tbhead{Equivalent Two-character Type} \\
    \midrule
    \texttt{v}\indexprefix{v} & (Column) Vector & \texttt{c1} \\
    \texttt{r}\indexprefix{r} & Row Vector & \texttt{c2} \\
    \texttt{m}\indexprefix{m} & Matrix & \texttt{c2} \\
    \texttt{t}\indexprefix{t} & Tensor & \texttt{c3} \\
    \texttt{d}\indexprefix{d} & Double & \texttt{f0} \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{warning}
  \texttt{v}, \texttt{r}, \texttt{m} and \texttt{t} are all for \textbf{complex} types.
  For a non-complex type, you need to use the normal two-character way.

  Row vector (\texttt{r}) is actually regarded as a matrix for simplicity,
  so its dimension is still 2.
  Only column vector (\texttt{v}) is the real vector.
  But there can be differences in terms of \func{INIT},
  so it should not be confused with \texttt{m}.
\end{warning}

\subsubsection{Dimension}\index{dimension}\label{d:subsubsec:dim}

Dimensions range from 0 to 3.
Details are shown in Table~\ref{d:tab:dim}.
\begin{table}[htbp]
  \caption{ALG variable dimension.}
  \label{d:tab:dim}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabularx}{\linewidth}{YYY}
    \toprule
    \tbhead{Dimension} & \tbhead{Type} & \tbhead{C++ Type} \\
    \midrule
    0 & Scalar & --- \\
    1 & Vector &
    \href{https://arma.sourceforge.net/docs.html\#Col}{\texttt{Col}} \\
    2 & Matrix &
    \href{https://arma.sourceforge.net/docs.html\#Mat}{\texttt{Mat}} \\
    3 & Tensor &
    \href{https://arma.sourceforge.net/docs.html\#Cube}{\texttt{Cube}} \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{warning}
  Dimension for a scalar can not be omitted.
\end{warning}

Please note that matrices are stored in \textbf{column major} order,
which is the default order in C++ (Armadillo) and Matlab/Octave. In
Python (NumPy), it is equivalent to the option
\lstinline[language=c,morekeywords={order}]{order='F'}.

\begin{warning}
  You should always remember the column \textbf{major order},
  especially if you use are accustomed to Python.
  The order will make a big difference to matrix reshape and vectorization.
\end{warning}

\subsubsection{Suffix}\index{suffix}\label{d:subsubsec:suffix}
All suffixes of ALG variables are shown in Table~\ref{d:tab:suffix}.

\begin{table}[htbp]
  \caption{ALG variable suffix.}
  \label{d:tab:suffix}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabularx}{\linewidth}{cYYYY}
    \toprule
    \tbhead{Suffix} & \tbhead{Meaning} & \tbhead{C++} & \tbhead{Python} & \tbhead{\textsc{Matlab}/Octave} \\
    \midrule
    \texttt{c}\indexsuffix{c} & Constant &
    \href{https://en.cppreference.com/w/cpp/language/cv}{\texttt{const}} &
    (None) &
    \href{https://www.mathworks.com/help/matlab/ref/persistent.html}{\texttt{persistent}} \\
    \texttt{r}\indexsuffix{r} & Reference &
    \href{https://en.cppreference.com/w/cpp/language/cv}{\texttt{reference}}
    & (None) & (None) \\
    \bottomrule
  \end{tabularx}
\end{table}

\begin{tip}
  Two suffixes cannot be used together and there is also no need to do so.
  The use of \texttt{r} is mainly in \texttt{function},
  allowing a parameter to be changed inside the function body.
\end{tip}

\section{Function}\index{function}

\subsection{Syntax Basics}
The initiative of proposing a new programming language for algorithm
implementation is based on the multi-backend design of mmCEsim.
The language is specially designed so that it can be exported to C++
(with Armadillo), Python (with NumPy) and \textsc{Matlab}/Octave easily.

Every line of ALG language calls a function.
Let's first have a look at its basic structure before we cover its details.
\begin{lstlisting}[language=mmcesim-sim, morekeywords={FUNC}]
ret1::type1 ret2 = FUNC param1 param2::type2 key1=value1 key2=value2::type3 # com.
\end{lstlisting}
It may look like an assembly language at the first glance,
due to all parameters are separated by space.
But it is actually much more convenient.
Here are some basic rules:
\begin{itemize}
  \item All tokens are separated by space.
  \item Function names are in all upper cases, like \lfunc{CALC}, \func{WHILE}.
  \item Indentation does not matter. Blocks are ended with \lfunc{END}.
  \item The function line is mainly composed of three parts:
  \textbf{return values}, \textbf{function name}, \textbf{parameters},
  in the left to right direction.
  \item Some functions may not have return values, and you may also omit the return values.
  If there are return values, there is a \texttt{=} between return values and function names.
  \item Function name is the first word on the right of \texttt{=} (if there are return values)
  or the first word of line (if there is no return value).
  \item Like Python, parameters can be passed in by two ways:
  \begin{enumerate}
    \item \textbf{value in position}: Like \texttt{param1} and \texttt{param2} in the above example.
    Parameters in different positions correspond to different usages in the function.
    This is the only way in C++.
    \item \textbf{key and value}: Parameters can also be specified using key and its
    corresponding value. \texttt{value1} and \texttt{value2} are passed in using this method.
    It should be noted that there should be no space around the \texttt{=} between key and value.
  \end{enumerate}
  There are some special cases that parameters are viewed as a whole,
  for example \lfunc{COMMENT} and \lfunc{CALC}.
  \item If a parameter contains space or special characters, you need to use the
  double quotes like \texttt{"param with space"} and escape special characters as in
  C++ and Python.
  \item You may optionally specify the type of return value and parameters with \texttt{::}
  after the value. For example, in the above example \texttt{dtype1}, \texttt{dtype2} and \texttt{dtype3}
  are type specifications for \texttt{ret1}, \texttt{param2} and \texttt{value2}, respectively.
  For more information about data type, please refer to \hyperref[d:sec:data_type]{data type of ALG language}.
  \item Like Python, the backslash (\texttt{\textbackslash}\indextt{\textbackslash}) at the end of the line can be used for continuing
  the function on next line.
  \item Comments start with the hash (\texttt{\#}\indextt{\#}) like Python.
\end{itemize}

\begin{warning}
  There should be no space around the \texttt{=} between key and value for parameters.
  For example, \texttt{key=val} is valid while \texttt{key = val} is forbidden.
\end{warning}

Special rules may be applied for different functions.
Please refer to the specific documentation for each function.

\funcsec{BRANCH}
Declare start of the scope of job algorithms.
\subsubsection*{Explanations}
This is useful in \texttt{estimation}.
Contents between \func{BRANCH} and \func{MERGE}
will be repeated for different algorithms.
So you need to place compressed sensing estimation
\func{ESTIMATE} and \func{RECOVER}
inside.
% This is useful in [`estimation`](../cli/config#estimation).
% Contents between `BRANCH` and [`MERGE`](#merge)
% will be repeated for different algorithms.
% So you need to place compressed sensing estimation
% [`ESTIMATE`](#estimate) and [`RECOVER`](#recover)
% inside.
\subsubsection*{Example}
\href{https://github.com/mmcesim/examples/blob/6500ae3021e06b583897f9554e694e86584064f0/MIMO_OFDM_OMP/MIMO_wideband.sim#L90}{Example of OFDM OMP}.

\funcsec{BREAK}
Break from a block (for \func{FOR}, \func{FOREVER}, \func{LOOP}, \func{WHILE}).
\subsubsection*{Explanations}
The same as \texttt{break} in C++, Python and \textsc{Matlab}/Octave.
This function takes no parameter.
\subsubsection*{Example}
Example with \func{FOREVER}.

\funcsec{CALC}
Make arithmetic calculations.
\subsubsection*{Explanations}
There are two kinds of \texttt{CALC} usage: \textbf{inline} and \textbf{standalone}:
\begin{itemize}
  \item \textbf{inline}: The contents to be calculated are placed in a set of dollar signs,
  like \LaTeX{} syntax: \ALG{$some operations to be calculated$}.
  \item \textbf{Standalone}: This is like a normal function, with function name as \func{CALC}.
  You may also omit the function name \func{CALC} since it is the default function name
  if nothing is specified.
  Therefore, \ALG{result = CALC your expression} is equivalent to \ALG{result = your expression}.
\end{itemize}
For more information about the \func{CALC} syntax,
please refer to \S\ref{d:sec:calc}.
\begin{warning}
  For safety, you should not use anything other than ANSI characters in \func{CALC} functions.
  Otherwise, there can be undefined behaviour.
\end{warning}
If you want the calculation result to be a new variable,
you may use function \func{NEW}.
\subsubsection*{Example}
\begin{example}[Example of CALC]~
  \begin{lstlisting}[language=mmcesim-sim]
a = CALC b + 2 # explicit CALC function
a = \sin(b) @ c # implicit CALC function
a = b^H + c^{-1} # conjugate transpose and inverse
c = b_{2, 3} # get element of a matrix
c = \abs{b_{:, 3}} + \pow(b_{}, 2) # use : in subscript & use {} for function
\exp2(a + c .* d) ./ e^T -f_{:,3,1:index} # element-wise operator and subscript : range
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++,morekeywords={sin,abs,exp2,pow}]
a = b + 2;
a = arma::sin(b) * c;
a = b.t() + c.i();
c = b(2, 3);
c = arma::abs(b(arma::span::all, 3)) + arma::pow(b, 2);
arma::exp2(a + c % d) / e.st() - f(arma::span::all, 3, arma::span(1, index));
  \end{lstlisting}
\end{example}

\funcsec{CALL}
Call a custom function defined by \lfunc{FUNCTION}.

\funcsec{COMMENT}
Place a line of comment in the exported code.
\subsubsection*{Explanations}
All contents after the function keyword \func{COMMENT} are considered as comments.
\subsubsection*{Example}
\begin{example}[Example of COMMENT]~
  \begin{lstlisting}[language=mmcesim-sim]
COMMENT Hi, this is a comment!
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++]
// Hi, this is a comment!
  \end{lstlisting}
  Equivalent Python Code
  \begin{lstlisting}[language=python]
# Hi, this is a comment!
  \end{lstlisting}
  Equivalent \textsc{Matlab}/Octave Code
  \begin{lstlisting}[language=matlab]
% Hi, this is a comment!
  \end{lstlisting}
\end{example}

\funcsec{CPP}
Write standard C++ contents.
\subsubsection*{Explanations}
All contents after the \func{CPP} keywords are copied to exported codes.
For backend other than C++, this function is ignored.
\subsubsection*{Example}
\begin{example}[Example of CPP]~
  \begin{lstlisting}[language=c++, morekeywords={CPP}]
CPP std::cout << "Standard C++ Language!" << std::endl;
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++]
std::cout << "Standard C++ Language!" << std::endl;
  \end{lstlisting}
  For Python, \textsc{Matlab}/Octave, nothing will happen with the \func{CPP} function.
\end{example}

\funcsec{ELIF}
\func{ELIF} is a shorthand for combining \lfunc{ELSE} and \lfunc{IF} statements into a continuous sequence.
\subsubsection*{Explanations}
The parameter is the same as \lfunc{IF}.
\subsubsection*{Example}
Example with \lfunc{IF}.

\funcsec{ELSE}
Used in \lfunc{IF} blocks.
\subsubsection*{Explanations}
This function implements as \texttt{else} in C++, Python and \textsc{Matlab}/Octave.
There is no parameter for the \func{ELSE} function.
\subsubsection*{Example}
Example with \lfunc{IF}.

\funcsec{END}
End of a block for \lfunc{ELSE}, \lfunc{ELIF}, \func{FUNCTION}, \func{FOREVER}, \lfunc{IF}, \func{LOOP}, \func{WHILE}.
\subsubsection*{Explanations}
In C++, this functions as \texttt{\}},
in Python it is the indentation goes back for one block.
In \textsc{Matlab}/Octave, it is the \texttt{end} specification.
\subsubsection*{Example}
Example with \func{FOR}, \func{FOREVER}, \lfunc{IF}, \func{LOOP}, \func{WHILE}.

\funcsec{ESTIMATE}
\lfunc{CALL} \hyperref[d:sec:alg_lib]{standard ALG functions}
or your custom algorithms to estimate the
sparse channel with compressed sensing (CS).

\funcsec{FOR}
Start a \texttt{for} loop.
\subsubsection*{Explanations}
The parameters are similar to C++, as listed in Table~\ref{d:tab:for_params}.
\begin{table}[htbp]
  \caption{ALG \texttt{FOR} function parameters.}
  \label{d:tab:for_params}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabularx}{\linewidth}{ccX}
    \toprule
    \tbhead{Position} & \tbhead{Parameter Key} & \tbhead{Descriptions} \\
    \midrule
    1 & \ALGkey{init}\indexTtt{FOR}{init} & Initialization before entering the loop. \\
    2 & \ALGkey{cond}\indexTtt{FOR}{cond} & Condition to continue into the loop. \\
    3 & \ALGkey{oper}\indexTtt{FOR}{oper} & Operation after each iteration. \\
    \bottomrule
  \end{tabularx}
\end{table}
\begin{warning}
  If there is \texttt{=} or other special characters inside your parameter or there exists space,
  do remember to place them inside double quotes (\texttt{"}).
\end{warning}
\subsubsection*{Example}
\begin{example}[Example of FOR]~
  \begin{lstlisting}[language=mmcesim-sim]
FOR "i::u0 = INIT 0" "i != 10" "i=i+2" # a for loop taking three parameters
  COMMENT "Do something here in the for loop."
END
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++]
for (uword i = 0; i != 10; i = i + 2) {
    // Do something here in the for loop.
}
  \end{lstlisting}
\end{example}

\funcsec{FOREVER}
Repeat in the block until \lfunc{BREAK}.
\subsubsection*{Example}
\begin{example}[Example of FOREVER]~
  \begin{lstlisting}[language=mmcesim-sim]
FOREVER # takes no param
  BREAK # Wow, nothing is done when I just break here [Lol]
END
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++]
while (1) {
    break;
}
  \end{lstlisting}
\end{example}

\funcsec{FUNCTION}
Start a function definition.
\subsubsection*{Explanations}
The function requires an \lfunc{END} to mark the end of the function.

\funcsec{IF}
Conditional statement.
\subsubsection*{Explanations}
This works the same as \texttt{if} in C++, Python, \textsc{Matlab}/Octave.
All contents after the \func{IF} keyword are part of the condition.
If you insist using the key value style, the key is \ALGkey{cond}.
\subsubsection*{Example}
\begin{example}[Example of IF]~
  \begin{lstlisting}[language=mmcesim-sim]
IF \accu(\pow(\abs(A), 2)) > 0.1 * threshold
  IF b < 0
    b = 0
  ELIF b > 100
    b = 100
  ELSE
    b = -b
  END
ELSE
  IF cond="c == d" # use key value style if you insist
    A = A * 0.1
  END
END
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++]
if (arma::accu(arma::pow(arma::abs(A), 2)) > 0.1 * threshold) {
    if (b < 0) {
        b = 0;
    } else if (b > 100) {
        b = 100;
    } else {
        b = -b;
    }
} else {
    if (c == d) {
        A = A * 0.1;
    }
}
  \end{lstlisting}
\end{example}

\funcsec{INIT}
Initialize a variable.
\subsubsection*{Explanations}
This function can initialize a \textbf{scalar}, a \textbf{vector}, a \textbf{matrix} and a \textbf{tensor}.
The initialization target can be specified in two ways:
\begin{itemize}
  \item \textbf{return value type specification}: You can specify the type of the variable to be
  initialized by \texttt{::};
  \item \textbf{parameters}: Parameter \ALGkey{dtype}\indexTtt{INIT}{dtype} is used for element type,
  and \ALGkey{dim1}\indexTtt{INIT}{dim1}, \ALGkey{dim2}\indexTtt{INIT}{dim2}, \ALGkey{dim3}\indexTtt{INIT}{dim3} are used for dimension specification.
\end{itemize}
\begin{warning}
  Please be \textbf{consistent}!
  The current implementation of the function is fragile and can be fooled by
  any inconsistent actions. While we are trying to enhance the error detection,
  you are advised to use the correct dimension.

  However, there are also a few exceptions for user's convenience.
  Though row vector (\texttt{r}) is regarded as a matrix,
  you can still specify its dimension with only one parameter on \ALGkey{dim1}.
  For a scalar initialization, the value can directly follow \texttt{=}.
\end{warning}
The parameters are listed in Table~\ref{d:tab:init_params}.
\begin{table}[htbp]
  \caption{ALG \texttt{INIT} function parameters.}
  \label{d:tab:init_params}
  \renewcommand{\arraystretch}{1.2}
  \begin{tabularx}{\linewidth}{ccX}
    \toprule
    \tbhead{Position} & \tbhead{Parameter Key} & \tbhead{Descriptions} \\
    \midrule
    1 & \ALGkey{dim1}\indexTtt{INIT}{dim1} & Size of the first dimension (for vector). \\
    2 & \ALGkey{dim2}\indexTtt{INIT}{dim2} & Size of the second dimension (for vector and matrix). \\
    3 & \ALGkey{dim3}\indexTtt{INIT}{dim3} & Size of the third dimension (for vector, matrix and tensor). \\\hdashline
    4 & \ALGkey{fill}\indexTtt{INIT}{fill} & Element filling mode.
      \ALGval{randn}\indexTTtt{INIT}{fill}{randn} for standard normal distribution $\mathcal{N}(0,1)$,
      \ALGval{randu}\indexTTtt{INIT}{fill}{randu} for standard uniform distribution $\mathcal{U}(0,1)$,
      \ALGval{zeros}\indexTTtt{INIT}{fill}{zeros} for filling as 0,
      \ALGval{ones}\indexTTtt{INIT}{fill}{ones} for filling as 1.
      Default is \ALGval{zeros}. \\\hdashline
    5 & \ALGkey{scale}\indexTtt{INIT}{scale} & Scale of the value.
      This works like multiplying a value after the initialization by \ALGkey{fill}. \\\hdashline
    6 & \ALGkey{dtype}\indexTtt{INIT}{dtype} & Element data type.
      This is the one character \hyperref[d:subsubsec:prefix]{prefix} like \texttt{c}, \texttt{i}.
      The default value is complex (\texttt{c}). \\
    \bottomrule
  \end{tabularx}
\end{table}
For initialization of a row vector (\texttt{r}), you may just use one dimension.
For initialization of a scalar (dimension as 0), you can specify the value directly after \texttt{=},
but if you want to use \ALGkey{fill} and \ALGkey{scale}, you must specify the parameter key.
\begin{tip}
  Since the development of ALG concentrates on matrix operations,
  the initialization also performs in a matrix-oriented way.
  Please refer to \hyperref[d:sec:data_type]{data type of ALG language} if you are not sure
  how to use the data type.
\end{tip}
\subsubsection*{Example}
\begin{example}[Example of INIT]~
  \begin{lstlisting}[language=mmcesim-sim]
a = INIT 4 3 fill=ones scale=4 dtype=c # a matrix
b::r = INIT 10 scale="-1+i" # row vector (viewed as a matrix)
pi::f0c = INIT 3.1415926 # a const float
random_number = INIT fill=randn scale=-2
  \end{lstlisting}
  Equivalent C++ Code
  \begin{lstlisting}[language=c++]
cx_mat a = (4) * arma::ones<cx_mat>(4, 3);
cx_mat b = (-1 + i) * arma::zeros<cx_mat>(1, 10);
const double pi = 3.1415926;
std::complex<double> random_number = (-2) * arma::randn<std::complex<double>>();
  \end{lstlisting}
\end{example}

\funcsec{LOG}
Write to log file.
\subsubsection*{Example}
\begin{example}[Example of INIT]~
  \begin{lstlisting}[language=mmcesim-sim]
LOG [INFO] A user-defined message.
  \end{lstlisting}
  Log file: \texttt{mmcesim.log}
  \begin{lstlisting}[]
[INFO] $ LOG [INFO] A user-defined message.
[INFO] * FUNCTION: LOG
[INFO] * PARAMS:
[INFO]    > {}={[INFO]}::{}
[INFO]    > {}={A}::{}
[INFO]    > {}={user-defined}::{}
[INFO]    > {}={message.}::{}
[INFO] A user-defined LOG message.
  \end{lstlisting}
\end{example}

\funcsec{LOOP}
Loop with iteration counter.

\section{Calculation (CALC)}\index{calculation}\index{CALC}\label{d:sec:calc}

\section{Macro}\index{macro}

\section{ALG Library}\index{ALG library}\label{d:sec:alg_lib}
